# CCF2019题解（C++描述）



# CCF201903

前2题

## 201903_1小中大

本题需要注意的是注意如果不是int保留一位小数

```C++
#include <iostream>

using namespace std;
int main(){
	int n;
	cin>>n;
	int arr[n];
	for(int i=0;i<n;i++)
		cin>>arr[i];
	int max,min;
	if(arr[0]<arr[n-1]){
		min=arr[0];
		max=arr[n-1];
	}else{
		min=arr[n-1];
		max=arr[0];
	}
	cout<<max<<" ";
	if(n%2==0){
		if((arr[n/2]+arr[(n/2)-1])%2==0){
			cout<<(arr[n/2]+arr[(n/2)-1])/2;
		}else{
			float f=(arr[n/2]+arr[(n/2)-1])/2.0;
			printf("%.1f",f);
		}
		
	}else{
		printf("%d",arr[n/2]); 
	}
	cout<<" "<<min;
	return 0;
} 
```



## 201903_2二十四点

本题为用栈实现简单计算器

```C++
#include <iostream>
#include <stack>

using namespace std;
int comper(char s1,char s2){
	if(((s1=='x'||s1=='/') and (s2=='+'||s2=='-')) or ((s1=='x'||s1=='/') and (s2=='x'||s2=='/')) or ((s1=='+'||s1=='-') and (s2=='+'||s2=='-'))){
		return 1;
	}
	return 0;
}

int cc(int pop,char opt,int b){
	if(opt=='/'){
		return pop/b; 
	}else if(opt=='x'){
		return pop*b;
	}else if(opt=='+'){
		return pop+b;
	}else if(opt=='-'){
		return pop-b;
	}
}

int cal(string s){
	//cout<<s<<"!"<<endl;
	stack<int> num;
	stack<char> opt;
	for(int i=0;i<s.size();i++){
		if(s[i]>='0' && s[i]<='9'){
			num.push(s[i]-'0');
			//cout<<"num压入了"<<s[i]-'0'<<endl;
		}else{
			if(opt.size()==0){
				opt.push(s[i]);
				//cout<<"null";
				//cout<<"opt压入了"<<s[i]<<endl;
			}else{
				char opt_top = opt.top();
				if(comper(opt_top,s[i])){
					//cout<<"此时符号小于栈顶"<<endl; 
					int pop1 = num.top();
					num.pop();
					int pop2 = num.top();
					num.pop();
					char op = opt.top();
					opt.pop();
					num.push(cc(pop2,op,pop1));
					i--;
					//cout<<"num压入了"<<cc(pop2,op,pop1)<<endl;
				}else{
					opt.push(s[i]);
					//cout<<"opt压入了"<<s[i]<<endl;
				}
			}
			
		}
	}

	//cout<<"===="<<endl;
//--------
	while(!opt.empty()){
		int pop1 = num.top();
		num.pop();
		int pop2 = num.top();
		num.pop();
		char op = opt.top();
		opt.pop();
		num.push(cc(pop2,op,pop1)); 
		//cout<<"num压入了"<<cc(pop2,op,pop1)<<endl;
	}
	return num.top();
}

int main(){
	int n;
	cin>>n;
	getchar();
	string str;
	for(int i=0;i<n;i++){
		getline(cin,str);
		int a=cal(str);
		if(a==24){
			cout<<"Yes"<<endl;
		}else{
			cout<<"No"<<endl;
		}
	}
	
	
	return 0;
} 
```



# CCF201909

前2题

## 201909_1小明种苹果

本题使用map<<x,y><周围，四角>>

```C++
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

int main(){
	int m,n;
	cin>>m>>n;
	int arr[m][n+1];
	int max_num[m];
	int max_value=0;
	int sum=0;
	for(int i=0;i<m;i++){
		int temp=0;
		for(int j=0;j<=n;j++){
			scanf("%d",&arr[i][j]);
			sum+=arr[i][j];
			if(j!=0){
				temp+=(-arr[i][j]);
			}
		}
		max_num[i]=temp;
		max_value = max(max_value,temp);
	}
	int usr;
	for(int i=0;i<m;i++){
		if(max_value==max_num[i]){
			usr=i+1;
			break;
		}
	}
	
	cout<<sum<<" "<<usr<<" "<<max_value;
	
	
	return 0;
} 
```



## 201909_2小明种苹果（续）

本题比上一题简单，考虑两个不能遍历到的情况

```C++
#include <iostream>

using namespace std;
int main(){
	int n;
	scanf("%d",&n);
	int flag[n]={0};
	int num=0;
	for(int k=0;k<n;k++){
		int m;
		scanf("%d",&m);
		int tol;
		scanf("%d",&tol);
		for(int i=1;i<m;i++){
			int temp;
			scanf("%d",&temp);
			if(temp>0){//计数 
				if(tol!=temp){//掉 
					flag[k]=1;
					tol=temp;
				}
			}else{//疏 
				tol+=temp;	
			}
		}
		num+=tol;
	}
	int D=0;
	for(int i=0;i<n;i++){
		if(flag[i]) D++;
	}
	
	//操作相邻
	//特殊情况
	int E = 0;
	if(flag[n-2] && flag[n-1] && flag[0]){
		E++;
	}
	if(flag[n-1] && flag[0] && flag[1]){
		E++;
	}
	for(int i=0;i<n-2;i++){
		if(flag[i] && flag[i+1] && flag[i+2]) E++;
	}
		
	
	cout<< num <<" "<< D <<" "<<E;
	
	return 0;
} 
```



# CCF201912

前3题

## 201912_1报数

略

```c++
#include <iostream>

using namespace std;
bool con(int n){
    for(;n!=0;n/=10){
        if(n%10==7) return true;
    }
    return false;
}

bool fun(int n){
    if(con(n) || n%7==0){
        return true;
    }
    return false;
}

int main(){
    int n;
    int a=0,b=0,c=0,d=0;
    cin>>n;
    for(int i=1,j=0;j<n;i++){
        if(i%4==1){
            if(fun(i)) a++;
            else j++;
        }else if(i%4==2){
            if(fun(i)) b++;
            else j++;
        }else if(i%4==3){
            if(fun(i)) c++;
            else j++;
        }else{
            if(fun(i)) d++;
            else j++;
        }
    }
    cout<<a<<endl;
    cout<<b<<endl;
    cout<<c<<endl;
    cout<<d<<endl;

    return 0;
}
```



## 201912_2回收站选址

map<<x,y>,<上下左右,四角>>

```C++
#include <iostream>
#include <map>
#include <array>

using namespace std;
int main(){
    map<array<int,2>,array<int,2>> m;
    int n;
    array<int,2> p;
    cin>>n;
    while(n--){
        cin>>p[0]>>p[1];
        m.insert({p,{0,0}});
        for(auto& i : m){
            auto& p2 = i.first;
            if((abs(p[0]-p2[0])==1 and p[1]==p2[1]) or //遍历map查找邻居和对角的垃圾
                (p[0]==p2[0] and abs(p[1]-p2[1]==1))){
                ++m[p][0];
                ++m[p2][0];
            } else if(abs(p[0]-p2[0])==1 and abs(p[1]-p2[1])==1){
                ++m[p][1];
                ++m[p2][1];
            }
        }
    }
    array<int,5> ans{};
    for(auto& i:m){
        if(i.second[0]==4){
            ans[i.second[1]]++;
        }
    }
    for(auto i:ans){
        cout<<i<<endl;
    }


    return 0;
}
```



## 201912_3 化学方程式

本题较复杂，考虑数字的三种位置

```c++
#include<iostream>
#include<map>
#include<sstream>
#include<vector>

using namespace std;

struct Elem{
	string name;
	int num;
	Elem(string _name,int _num):name(_name),num(_num){}
};

int toNumber(string str,int &pos){
	int num = 0;
	while(isdigit(str[pos])){
		num = num*10 + str[pos]-'0';
		pos++;
	}
	return num;
}

void calc(string str,map<string,int> &mp){

	stringstream ss(str);
	string item;

	while(getline(ss,item,'+')){

		vector<Elem> arr;
		int factor = 1;
		int i = 0;//index

		if(isdigit(item[i])){
			factor = toNumber(item,i);
		}

		while(i<item.size()){
			if(isdigit(item[i])){
				int num = toNumber(item,i);
				if(arr[arr.size()-1].name==")"){
					int j = arr.size()-1;
					arr[j].name = "*";
					while(arr[--j].name!="("){
						arr[j].num*=num;
					}
					arr[j].name="*";
				}else{
					arr[arr.size()-1].num *= num;
				}
			}else if(isupper(item[i])){
				string name="";
				name+=item[i];
				i++;
				if(islower(item[i])){
					name+=item[i];
					i++;
				}
				arr.push_back(Elem(name,1));
			}else if(item[i]=='('){
				arr.push_back(Elem("(",0));
				i++;
			}else if(item[i]==')'){
				arr.push_back(Elem(")",0));
				if(!isdigit(item[i+1])){
					item.insert(i+1,"1");
				}
				i++;
			}
		}
		for(int i=0;i<arr.size();i++){
			if(arr[i].name!="*"){
                mp[arr[i].name]+=arr[i].num*factor;
			}

		}
	}
}


bool judge(map<string,int> &left,map<string,int> &right){
	if(left.size()!=right.size()) return false;
	map<string,int>::iterator it;
	for(it=left.begin();it!=left.end();it++){
		if(right[it->first]!=it->second) return false;
	}
	return true;
}



int main(){
	int n;
	scanf("%d",&n);
	while(n--){
		map<string,int> left,right;
		string str,lstr,rstr;
		cin>>str;
		stringstream ss(str);
		getline(ss,lstr,'=');
		getline(ss,rstr);

		calc(lstr,left);
		calc(rstr,right);

		for(map<string,int>::iterator it=left.begin();it!=left.end();it++){
		    cout<<it->first<<" "<<it->second<<endl;
		}
        for(map<string,int>::iterator it=right.begin();it!=right.end();it++){
            cout<<it->first<<" "<<it->second<<endl;
        }

		if(judge(left,right)) cout<<"Y"<<endl;
		else cout<<"N"<<endl;
	}
	return 0;
}

```

